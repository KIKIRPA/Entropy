<?php
  // prevent direct access to this file (thus only when included)
  if (count(get_included_files()) == 1) 
  {
    header($_SERVER["SERVER_PROTOCOL"]." 404 Not Found");
    header("Status: 404 Not Found");
    exit("Direct access not permitted.");
  }
  
/*****************************************************************************************************
  CONCEPT:
    Hierarchical metadata can be stored in "flat" or "deep" arrays.
    
    Flat arrays:
      e.g. <id> -> array( "samplename:C.I. number" -> "1234",
                          "allowformats"           -> "spc|dx|txt" )
    
    Deep arrays are multi-level arrays based on keyseparation and (optionally) fieldseparation
      - keyseparation: <samplename:C.I. number>   --> $keysep default ":"
      - fieldseparation: <allowformats>spc|dx|txt --> $fieldsep default "|"
      e.g id> -> array( "samplename"     -> array( "C.I. number" -> "1234",
                                                   "C.I. name"   -> "PY1" ),
                        "allowformats"   -> array( 0 -> "spc",
                                                   1 -> "dx",
                                                   2 -> "txt" ))
  
  FUNCTIONS:
  
    corrFilename($string, $replaceby = "_")
      remove all characters that should not be there to be used as a part of a filename
    
    csv2array($handle, $key, $delimiter = ",", $enclosure = '"', $escape = "\\")
        converts a CSV file handle into a flat array.
        IN: $handle (CSV file), $key (unique and required id column name)
            (optional:) CSV delimiter, enclosure and escape characters
        OUT: flat array (or error msg in string format)
    
    array2csv($handle, $array, $sort = false, $delimiter = ",", $enclosure = '"', $escape = "\\")
        converts a flat array into a CVS handle
        IN: $handle (CSV file), $array (flat data array)
            (optional:) $sort (boolean to sort the headers alphabetically), 
                        CSV delimiter, enclosure and escape characters
        OUT: file handle formatted with CSV
        
    checkUpload($uploadArr, $updir, $filename = null)
        sanity checks for uploaded files and copy the file to $updir, and optionally renames it
        into $filename.
        OUT: False if ok, errormsg if not
        
    checkMultiUpload($uploadArr, $pathPrefix)
        version of checkUpload() for multiple uploads. $pathPrefix can be the path where to save
        the files including trailing /, but can also include a prefix for the filename 
        (e.g: ./lib/sop/upload/sampleid__)
        OUT: False if ok, errormsg if not

*****************************************************************************************************/ 
  
  
  function corrFilename($string, $replaceby = "_")
  {
    $replace = str_split(" !\"#$%&'()*+,/:;<=>?@[\\]^`{}~");
    $string = str_replace($replace, $replaceby, $string);
    $string = preg_replace('/[' . $replaceby . ']+/', $replaceby, $string);  // replace multiple underscores by a single
    $string = trim($string, "_");
    
    return filter_var($string, FILTER_SANITIZE_STRING, FILTER_FLAG_STRIP_LOW | FILTER_FLAG_STRIP_HIGH);
  }

  
  
  function csv2array($handle, $key, $keepempty = true, $delimiter = ",", $enclosure = '"', $escape = "\\")
  {
    $array = array();
    
    //first line are the column names: making the variables 
    $headings = fgetcsv($handle, 0, $delimiter, $enclosure, $escape);
    if (!$headings)                   return "Error in the CSV file.";
    if (!in_array($key, $headings)) return "CSV is missing the required key \"" . $key . "\".";
    
    //data lines are next
    while ($line = fgetcsv($handle, 0, $delimiter, $enclosure, $escape))
    {
      unset($id);
      $temp = array();
      
      $line = array_map('utf8_encode', $line);   //excel makes iso8859-1, but json nulls all vars with special characters
      
      foreach ($line as $i => $value) 
      {
        if ($value != "" or $keepempty)
        {
          if ($headings[$i] == $key) $id = $value;
          else                       $temp[$headings[$i]] = $value;
        }
      }

      if (isset($id)) $array[$id] = $temp;              
    }
    
    if (empty($array)) return "Error in the CSV file.";
    else               return $array;
  }  
   
  
  
  function array2csv($handle, $array, $sort = false, $delimiter = ",", $enclosure = '"', $escape = "\\")
  {  
    /*
    takes an opened file handle and a _flat_ array (array of array (records) with a flat structure as generated by flattenArray() )
    optional $sort sorts the headers alphabetically
    optional $delimiter, $enclosure and $escape define the CSV output
    
    returns true upon success and false upon failure
    */
    
    //making a header line:
    $headers = array();
    foreach ($array as $record)
      foreach ($record as $header => $value)
        if (!in_array($header, $headers)) array_push($headers, $header);
    if ($sort) sort($headers);
    
    $return = fputcsv($handle, $headers, $delimiter, $enclosure);
    
    //making the data lines:
    if ($return)
    {
      foreach ($array as $record)
      {
        $line = array();
        foreach ($headers as $header)
        {
          if (isset($record[$header])) array_push($line, $record[$header]);
          else                         array_push($line, "");
        }
        $return = fputcsv($handle, $line, $delimiter, $enclosure);
        if (!$return) return false;
      }
    }
    else return false;
    
    return true;
  }
  
  
  function checkUpload($upload, $updir, $filename = null)
  {
    if ($filename === null) $filename = $_FILES[$upload]["name"];
    
    // Undefined | Multiple Files | $_FILES Corruption Attack
    // If this request falls under any of them, treat it invalid.
    if (!isset($_FILES[$upload]['error']) || is_array($_FILES[$upload]['error']))
      return 'Invalid parameters.';

    // Check $_FILES[$upload]['error'] value.
    switch ($_FILES[$upload]['error']) 
    {
      case UPLOAD_ERR_OK:
        break;
      case UPLOAD_ERR_NO_FILE:
        return 'No file sent.';
      case UPLOAD_ERR_INI_SIZE:
      case UPLOAD_ERR_FORM_SIZE:
        return 'Exceeded filesize limit [html limit].';
      default:
        return 'Unknown errors.';
    }

    // You should also check filesize here.
    if ($_FILES[$upload]['size'] > 2000000)
      return 'Exceeded filesize limit [php limit].';
        
    // move file to uploads
    if (!mkdir2($updir))
      return 'Could not create upload directory.';
    if (!move_uploaded_file($_FILES[$upload]["tmp_name"], $updir . $filename))
      return 'Could not save ' . $filename . ' in the upload directory.';
      
    return False;
  }

  
  function checkMultiUpload($upload, $updir, $prefix = "")
  {
    // Undefined | Multiple Files | $_FILES Corruption Attack
    // If this request falls under any of them, treat it invalid.
    if (!isset($_FILES[$upload]['error']))
      return 'Invalid parameters.';
 
    // Check $_FILES[$upload]['error'] values.
    foreach ($_FILES[$upload]['error'] as $i => $value)
    {
      switch ($value) 
      {
        case UPLOAD_ERR_OK:
          break;
        case UPLOAD_ERR_NO_FILE:
          return 'File ' . $i . ': No file sent.';
        case UPLOAD_ERR_INI_SIZE:
        case UPLOAD_ERR_FORM_SIZE:
          return 'File ' . $i . ': Exceeded filesize limit [html limit].';
        default:
          return 'File ' . $i . ': Unknown errors.';
      }
    }

    // You should also check filesize here.
    foreach ($_FILES[$upload]['size'] as $i => $value)
      if ($value > 2000000)
        return 'File ' . $i . ': Exceeded filesize limit [php limit].';
        
    // move files to uploads
    if (!mkdir2($updir))
      return 'Could not create upload directory.';
    
    foreach($_FILES[$upload]["tmp_name"] as $i => $value)
      if (!move_uploaded_file($value, $updir . $prefix . basename($value)))
        return 'Could not save ' . $prefix . basename($_FILES[$upload]["tmp_name"][$i]) . ' in the upload directory.';
      
    return False;
  }
  
  
?> 
